jQuery(document).ready(function(e) {
    // Initialize scroller after windiw load	
        $(window).load(function(){
        
            jQuery('.nano').nanoScroller({
                preventPageScrolling: true
                  });
    
            jQuery(".nano").nanoScroller();
    
        }); 
    //Re-Initialize scroller on li height change
        $('.content li').bind('resize',function(e) {
           jQuery(".nano").nanoScroller();
           });
    
    });
    
    //Detect height change and update scroller height
    //'.content li' is taken as reference height detector
    (function($,window,undefined){
      '$:nomunge'; // Used by YUI compressor.
      var elems = $([]),
        jq_resize = $.resize = $.extend( $.resize, {} ),
        
        timeout_id,
        
        // Reused strings.
        str_setTimeout = 'setTimeout',
        str_resize = 'resize',
        str_data = str_resize + '-special-event',
        str_delay = 'delay',
        str_throttle = 'throttleWindow';
      
      jq_resize[ str_delay ] = 250;
      
      jq_resize[ str_throttle ] = true;
      
        
      $.event.special[ str_resize ] = {
        
        // Called only when the first 'resize' event callback is bound per element.
        setup: function() {
    
          if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
          
          var elem = $(this);
          
          // Add this element to the list of internal elements to monitor.
          elems = elems.add( elem );
          
          // Initialize data store on the element.
          $.data( this, str_data, { w: elem.width(), h: elem.height() } );
          
          // If this is the first element added, start the polling loop.
          if ( elems.length === 1 ) {
            loopy();
          }
        },
        
        // Called only when the last 'resize' event callback is unbound per element.
        teardown: function() {
    
          if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
          
          var elem = $(this);
          
          // Remove this element from the list of internal elements to monitor.
          elems = elems.not( elem );
          
          // Remove any data stored on the element.
          elem.removeData( str_data );
          
          // If this is the last element removed, stop the polling loop.
          if ( !elems.length ) {
            clearTimeout( timeout_id );
          }
        },
        
        add: function( handleObj ) {
    
          if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
          
          var old_handler;
          
             function new_handler( e, w, h ) {
            var elem = $(this),
              data = $.data( this, str_data );
            
            // If called from the polling loop, w and h will be passed in as
            // arguments. If called manually, via .trigger( 'resize' ) or .resize(),
            // those values will need to be computed.
            data.w = w !== undefined ? w : elem.width();
            data.h = h !== undefined ? h : elem.height();
            
            old_handler.apply( this, arguments );
          };
          
          // This may seem a little complicated, but it normalizes the special event
          // .add method between jQuery 1.4/1.4.1 and 1.4.2+
          if ( $.isFunction( handleObj ) ) {
            // 1.4, 1.4.1
            old_handler = handleObj;
            return new_handler;
          } else {
            // 1.4.2+
            old_handler = handleObj.handler;
            handleObj.handler = new_handler;
          }
        }
        
      };
      
      function loopy() {
        
        // Start the polling loop, asynchronously.
        timeout_id = window[ str_setTimeout ](function(){
          
          // Iterate over all elements to which the 'resize' event is bound.
          elems.each(function(){
            var elem = $(this),
              width = elem.width(),
              height = elem.height(),
              data = $.data( this, str_data );
            
            // If element size has changed since the last time, update the element
            // data store and trigger the 'resize' event.
            if ( width !== data.w || height !== data.h ) {
              elem.trigger( str_resize, [ data.w = width, data.h = height ] );
            }
            
          });
          
          // Loop.
          loopy();
          
        }, jq_resize[ str_delay ] );
        
      };
      
    })(jQuery,this);
    
    